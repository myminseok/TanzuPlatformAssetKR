apiVersion: carto.run/v1alpha1
kind: ClusterConfigTemplate
metadata:
  annotations:
    doc: |
      This template consumes an input named config which contains a
      PodTemplateSpec and returns a ConfigMap which contains a
      "delivery.yml" which contains a manifests for a Kubernetes
      Deployment which will run the templated pod, and a "service.yml"
      Kubernetes Service to expose the pods on the network.
    kapp.k14s.io/identity: v1;/carto.run/ClusterConfigTemplate/server-template;carto.run/v1alpha1
    kapp.k14s.io/original: '{"apiVersion":"carto.run/v1alpha1","kind":"ClusterConfigTemplate","metadata":{"annotations":{"doc":"This template consumes an input named config which contains a\nPodTemplateSpec and returns a ConfigMap which contains a\n\"delivery.yml\" which contains a manifests for a Kubernetes\nDeployment which will run the templated pod, and a \"service.yml\"\nKubernetes Service to expose the pods on the network.\n"},"labels":{"kapp.k14s.io/app":"1718766694889982496","kapp.k14s.io/association":"v1.ef719e60ce217ebb01c859351dd7975e"},"name":"server-template"},"spec":{"configPath":".data","healthRule":{"alwaysHealthy":{}},"params":[{"default":[{"containerPort":8080,"name":"http","port":8080}],"name":"ports"}],"ytt":"#@ load(\"@ytt:data\", \"data\")\n#@ load(\"@ytt:yaml\", \"yaml\")\n#@ load(\"@ytt:struct\", \"struct\")\n#@ load(\"@ytt:assert\", \"assert\")\n\n#@ def merge_labels(fixed_values):\n#@   labels = {}\n#@   if hasattr(data.values.workload.metadata, \"labels\"):\n#@     exclusions = [\"kapp.k14s.io/app\", \"kapp.k14s.io/association\"]\n#@     for k,v in dict(data.values.workload.metadata.labels).items():\n#@       if k not in exclusions:\n#@         labels[k] = v\n#@       end\n#@     end\n#@   end\n#@   labels.update(fixed_values)\n#@   return labels\n#@ end\n\n#@ def intOrString(v):\n#@   return v if type(v) == \"int\" else int(v.strip()) if v.strip().isdigit() else v\n#@ end\n\n#@ def merge_ports(ports_spec, containers):\n#@   ports = {}\n#@   for c in containers:\n#@     for p in getattr(c, \"ports\", []):\n#@       ports[p.containerPort] = {\"targetPort\": p.containerPort, \"port\": p.containerPort, \"name\": getattr(p, \"name\", str(p.containerPort))}\n#@     end\n#@   end\n#@   for p in ports_spec:\n#@     targetPort = getattr(p, \"containerPort\", p.port)\n#@     type(targetPort) in (\"string\", \"int\") or fail(\"containerPort must be a string or int\")\n#@     targetPort = intOrString(targetPort)\n#@     \n#@     port = p.port\n#@     type(port) in (\"string\", \"int\") or fail(\"port must be a string or int\")\n#@     port = int(port)\n#@     ports[p.port] = {\"targetPort\": targetPort, \"port\": port, \"name\": getattr(p, \"name\", str(p.port))}\n#@   end\n#@   return ports.values()\n#@ end\n\n#@ def delivery():\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: #@ data.values.workload.metadata.name\n  annotations:\n    kapp.k14s.io/update-strategy: \"fallback-on-replace\"\n    ootb.apps.tanzu.vmware.com/servicebinding-workload: \"true\"\n    kapp.k14s.io/change-rule: \"upsert after upserting servicebinding.io/ServiceBindings\"\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"run\", \"carto.run/workload-name\": data.values.workload.metadata.name })\nspec:\n  selector:\n    matchLabels: #@ data.values.config.metadata.labels\n  template: #@ data.values.config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: #@ data.values.workload.metadata.name\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"run\", \"carto.run/workload-name\": data.values.workload.metadata.name })\nspec:\n  selector: #@ data.values.config.metadata.labels\n  ports:\n  #@ hasattr(data.values.params, \"ports\") and len(data.values.params.ports) or assert.fail(\"one or more ports param must be provided.\")\n  #@ declared_ports = []\n  #@ if \"ports\" in data.values.params:\n  #@   declared_ports = data.values.params.ports\n  #@ else:\n  #@   declared_ports = struct.encode([{ \"containerPort\": 8080, \"port\": 8080, \"name\": \"http\"}])\n  #@ end\n  #@ for p in merge_ports(declared_ports, data.values.config.spec.containers):\n  - #@ p\n  #@ end\n#@ end\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: #@ data.values.workload.metadata.name + \"-server\"\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"config\" })\ndata:\n  delivery.yml: #@ yaml.encode(delivery())\n"}}'
    kapp.k14s.io/original-diff-md5: 9748792b3045a6866cfbd621ca9f156a
  creationTimestamp: "2024-06-19T03:11:35Z"
  generation: 1
  labels:
    kapp.k14s.io/app: "1718766694889982496"
    kapp.k14s.io/association: v1.ef719e60ce217ebb01c859351dd7975e
  name: custom-server-template
  resourceVersion: "29342"
  uid: 13275cfc-d88e-4b0c-8489-dd216a0a45f0
spec:
  configPath: .data
  healthRule:
    alwaysHealthy: {}
  lifecycle: mutable
  params:
    - default:
        - containerPort: 8080
          name: http
          port: 8080
      name: ports
  ytt: "#@ load(\"@ytt:data\", \"data\")\n#@ load(\"@ytt:yaml\", \"yaml\")\n#@ load(\"@ytt:struct\", \"struct\")\n#@ load(\"@ytt:assert\", \"assert\")\n\n#@ def merge_labels(fixed_values):\n#@   labels = {}\n#@   if hasattr(data.values.workload.metadata, \"labels\"):\n#@     exclusions = [\"kapp.k14s.io/app\", \"kapp.k14s.io/association\"]\n#@     for k,v in dict(data.values.workload.metadata.labels).items():\n#@       if k not in exclusions:\n#@         labels[k] = v\n#@       end\n#@     end\n#@   end\n#@   labels.update(fixed_values)\n#@   return labels\n#@ end\n\n#@ def intOrString(v):\n#@   return v if type(v) == \"int\" else int(v.strip()) if v.strip().isdigit() else v\n#@ end\n\n#@ def merge_ports(ports_spec, containers):\n#@   ports = {}\n#@   for c in containers:\n#@     for p in getattr(c, \"ports\", []):\n#@       ports[p.containerPort] = {\"targetPort\": p.containerPort, \"port\": p.containerPort, \"name\": getattr(p, \"name\", str(p.containerPort))}\n#@     end\n#@   end\n#@   for p in ports_spec:\n#@     targetPort = getattr(p, \"containerPort\", p.port)\n#@     type(targetPort) in (\"string\", \"int\") or fail(\"containerPort must be a string or int\")\n#@     targetPort = intOrString(targetPort)\n#@     \n#@     port = p.port\n#@     type(port) in (\"string\", \"int\") or fail(\"port must be a string or int\")\n#@     port = int(port)\n#@     ports[p.port] = {\"targetPort\": targetPort, \"port\": port, \"name\": getattr(p, \"name\", str(p.port))}\n#@   end\n#@   return ports.values()\n#@ end\n\n#@ def delivery():\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: #@ data.values.workload.metadata.name\n  annotations:\n    kapp.k14s.io/update-strategy: \"fallback-on-replace\"\n    ootb.apps.tanzu.vmware.com/servicebinding-workload: \"true\"\n    kapp.k14s.io/change-rule: \"upsert after upserting servicebinding.io/ServiceBindings\"\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"run\", \"carto.run/workload-name\": data.values.workload.metadata.name })\nspec:\n  selector:\n    matchLabels: #@ data.values.config.metadata.labels\n  template: #@ data.values.config\n  #! added\n  replicas: #@ data.values.params.replicas \n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: #@ data.values.workload.metadata.name\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"run\", \"carto.run/workload-name\": data.values.workload.metadata.name })\nspec:\n  selector: #@ data.values.config.metadata.labels\n  ports:\n  #@ hasattr(data.values.params, \"ports\") and len(data.values.params.ports) or assert.fail(\"one or more ports param must be provided.\")\n  #@ declared_ports = []\n  #@ if \"ports\" in data.values.params:\n  #@   declared_ports = data.values.params.ports\n  #@ else:\n  #@   declared_ports = struct.encode([{ \"containerPort\": 8080, \"port\": 8080, \"name\": \"http\"}])\n  #@ end\n  #@ for p in merge_ports(declared_ports, data.values.config.spec.containers):\n  - #@ p\n  #@ end\n#@ end\n\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n#! TODO modified\n  name: #@ data.values.workload.metadata.name + \"-custom-server\"\n  labels: #@ merge_labels({ \"app.kubernetes.io/component\": \"config\" })\ndata:\n  delivery.yml: #@ yaml.encode(delivery())"
